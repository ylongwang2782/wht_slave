# 工厂测试模式使用指南

## 概述

本文档描述如何使用新实现的工厂测试模式功能。工厂测试模式允许测试工装通过串口控制底板的GPIO引脚，实现自动化测试。

## 进入工厂测试模式

### 1. 硬件触发方式
- 设备使用DIP6开关（PF9引脚）作为工厂测试模式触发器
- DIP6开关为低电平时，设备启动后自动进入工厂测试模式
- DIP6开关为高电平时，设备正常启动

### 2. 进入步骤
1. 将DIP6开关设置为ON（低电平）位置
2. 给设备上电
3. 设备检测到DIP6为低电平后会通过DEBUG串口输出："Factory test mode activated (DIP6 detected)"
4. 此时设备进入工厂测试模式，停止正常功能，专门处理工厂测试协议

### 3. 退出工厂测试模式
1. 断电
2. 将DIP6开关设置为OFF（高电平）位置
3. 重新上电，设备将正常启动

## 工厂测试协议

### 数据帧格式
```
[SOF(2B)] [Source(1B)] [Target(1B)] [MSG_ID(1B)] [Length(2B)] [Payload(NB)] [CRC16(2B)] [EOF(2B)]
```

- SOF: 0xAA55 (小端: 55 AA)
- Source: 0x01 (工装) 或 0x02 (底板)
- Target: 0x02 (底板) 或 0x01 (工装)
- MSG_ID: 消息类型
- Length: Payload长度 (小端)
- CRC16: CRC16-MODBUS校验码 (小端)
- EOF: 0x66BB (小端: BB 66)

### 支持的消息类型

#### 1. 心跳检测 (MSG_ID = 0x0F)
**用途**: 检查设备是否在线

**工装→底板**:
```
55 AA 01 02 0F 00 00 [CRC16] BB 66
```

**底板→工装**:
```
55 AA 02 01 0F 01 00 [Status] [CRC16] BB 66
```
- Status: 0x00=正常, 0x01=忙碌, 0xFF=错误

#### 2. GPIO控制 (MSG_ID = 0x10)
**用途**: 控制GPIO引脚的模式、上下拉、电平等

支持的子命令：
- 0x01: 设置引脚模式
- 0x02: 配置上下拉
- 0x03: 写输出电平
- 0x04: 读输入电平

#### 3. 64路IO控制 (MSG_ID = 0x11)
**用途**: 控制64路IO

支持的子命令：
- 0x01: 设置引脚模式
- 0x02: 配置上下拉
- 0x03: 写输出电平
- 0x04: 读输入电平

**数据格式**:
- 设置/配置命令: `[Sub-ID(1B)] [Pin-Mask(8B)] [Value(1B)]`
- 设置/配置响应: `[Sub-ID(1B)] [Status(1B)]`
- 读取命令: `[Sub-ID(1B)]`
- 读取响应: `[Sub-ID(1B)] [Status(1B)] [Levels(8B)]`

#### 4. 拨码开关控制 (MSG_ID = 0x12)
**用途**: 控制8位拨码开关

支持的子命令：
- 0x01: 设置引脚模式
- 0x02: 配置上下拉
- 0x03: 写输出电平
- 0x04: 读输入电平

**数据格式**:
- 设置/配置命令: `[Sub-ID(1B)] [Pin-Mask(1B)] [Value(1B)]`
- 设置/配置响应: `[Sub-ID(1B)] [Status(1B)]`
- 读取命令: `[Sub-ID(1B)]`
- 读取响应: `[Sub-ID(1B)] [Status(1B)] [Levels(1B)]`

## 测试示例

### 示例1: 设置PC8和PC9为推挽输出

**工装发送**:
```
55 AA 01 02 10 05 00 01 02 00 03 01 40 02 BB 66
```
解析：
- MSG_ID: 0x10 (GPIO控制)
- Sub-ID: 0x01 (设置模式)
- Port: 0x02 (PORTC)
- Mask: 0x0300 (PC8, PC9)
- Value: 0x01 (推挽输出)

**底板回复**:
```
55 AA 02 01 10 02 00 01 00 8E 0E BB 66
```
解析：
- Sub-ID: 0x01 (设置模式)
- Status: 0x00 (成功)

### 示例2: 控制PC8和PC9输出高电平

**工装发送**:
```
55 AA 01 02 10 05 00 03 02 00 03 01 C3 46 BB 66
```
解析：
- Sub-ID: 0x03 (写输出电平)
- Port: 0x02 (PORTC)
- Mask: 0x0300 (PC8, PC9)
- Value: 0x01 (高电平)

**底板回复**:
```
55 AA 02 01 10 02 00 03 00 EC 68 BB 66
```

### 示例3: 读取PORTC所有引脚电平

**工装发送**:
```
55 AA 01 02 10 02 00 04 02 5B C7 BB 66
```
解析：
- Sub-ID: 0x04 (读取电平)
- Port: 0x02 (PORTC)

**底板回复**:
```
55 AA 02 01 10 04 00 04 02 FF FE A3 01 BB 66
```
解析：
- Sub-ID: 0x04 (读取电平)
- Port: 0x02 (PORTC)
- Levels: 0xFEFF (PC9为低，其他为高)

### 示例4: 设置64路IO的第1和第2路为输出模式

**工装发送**:
```
55 AA 01 02 11 0A 00 01 03 00 00 00 00 00 00 00 01 [CRC16] BB 66
```
解析：
- MSG_ID: 0x11 (64路IO控制)
- Sub-ID: 0x01 (设置模式)
- Pin-Mask: 0x0000000000000003 (IO1, IO2，小端格式)
- Value: 0x01 (推挽输出)

**底板回复**:
```
55 AA 02 01 11 02 00 01 00 [CRC16] BB 66
```
解析：
- Sub-ID: 0x01 (设置模式)
- Status: 0x00 (成功)

### 示例5: 设置64路IO的第1和第2路为高电平

**工装发送**:
```
55 AA 01 02 11 0A 00 03 03 00 00 00 00 00 00 00 01 [CRC16] BB 66
```
解析：
- MSG_ID: 0x11 (64路IO控制)
- Sub-ID: 0x03 (写输出电平)
- Pin-Mask: 0x0000000000000003 (IO1, IO2，小端格式)
- Value: 0x01 (高电平)

**底板回复**:
```
55 AA 02 01 11 02 00 03 00 [CRC16] BB 66
```
解析：
- Sub-ID: 0x03 (写输出电平)
- Status: 0x00 (成功)

### 示例6: 读取8位拨码开关状态

**工装发送**:
```
55 AA 01 02 12 01 00 04 [CRC16] BB 66
```
解析：
- MSG_ID: 0x12 (拨码开关控制)
- Sub-ID: 0x04 (读取电平)

**底板回复**:
```
55 AA 02 01 12 03 00 04 00 5A [CRC16] BB 66
```
解析：
- Sub-ID: 0x04 (读取电平)
- Status: 0x00 (成功)
- Levels: 0x5A (拨码开关状态)

## 特殊IO映射

### 64路IO映射
- IO1~IO64 对应引脚掩码的bit 0~63
- 支持跨多个GPIO端口的批量操作

### 8位拨码开关映射
- DIP1~DIP8 对应引脚掩码的bit 0~7
- 所有拨码开关分布在GPIOC和GPIOF端口上

## 端口映射

| Port ID | GPIO端口 |
|---------|----------|
| 0x00    | GPIOA    |
| 0x01    | GPIOB    |
| 0x02    | GPIOC    |
| 0x03    | GPIOD    |
| 0x04    | GPIOE    |
| 0x05    | GPIOF    |
| 0x06    | GPIOG    |
| 0x07    | GPIOH    |

## 引脚掩码

引脚掩码使用16位值，每一位对应一个引脚：
- Bit 0 = Pin 0
- Bit 1 = Pin 1
- ...
- Bit 15 = Pin 15

例如：
- 0x0001 = Pin 0
- 0x0002 = Pin 1
- 0x0300 = Pin 8 和 Pin 9

## 状态码

| 状态码 | 含义 |
|--------|------|
| 0x00   | 成功 |
| 0x01   | 无效端口 |
| 0x02   | 无效引脚 |
| 0x03   | 无效子命令 |
| 0x04   | 执行错误 |

## 系统架构

### 数据处理流程
工厂测试模式采用了中断+任务的双层处理架构，确保系统稳定性：

1. **中断层**: 串口中断接收到数据后，仅将数据存储到256字节的环形缓冲区
2. **任务层**: UART命令处理任务每100ms检查一次环形缓冲区，处理完整的协议帧
3. **响应处理**: 协议解析和GPIO操作在任务上下文中执行，避免中断中的复杂操作

### 优势
- **稳定性**: 中断处理时间极短，不会影响系统实时性
- **可靠性**: 环形缓冲区防止数据丢失
- **效率**: 任务中批量处理数据，减少系统开销

## 注意事项

1. **硬件要求**: 必须确保DIP6开关能够正确切换到低电平
2. **启动检测**: 设备只在启动时检测DIP6状态，运行过程中切换DIP6不会改变模式
3. **功能暂停**: 进入工厂测试模式后，设备的正常功能将被暂停
4. **GPIO时钟**: 所有GPIO操作会自动启用相应端口的时钟
5. **数据校验**: CRC校验失败的数据包会被忽略
6. **功能限制**: 目前只实现了MSG_ID=0x10的功能，其他消息类型返回未实现错误
7. **模式切换**: 工厂测试模式需要重新上电才能退出
8. **处理延迟**: 协议帧在任务中每100ms处理一次，最大响应延迟约100ms
9. **缓冲区容量**: 环形缓冲区大小为256字节，足够处理正常的测试通信
